// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace YouMeProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class NameValue;
class PacketHead;
class ReqHead;
class ServerPacketHead;
class ServerReqHead;

enum Device_Platform {
  Platform_Unknow = 0,
  Platform_Android = 1,
  Platform_IOS = 2,
  Platform_Windows = 3,
  Platform_OSX = 4,
  Platform_Linux = 5
};
bool Device_Platform_IsValid(int value);
const Device_Platform Device_Platform_MIN = Platform_Unknow;
const Device_Platform Device_Platform_MAX = Platform_Linux;
const int Device_Platform_ARRAYSIZE = Device_Platform_MAX + 1;

enum NetworkType {
  NetworkType_Unknow = 0,
  NetworkType_3G = 1,
  NetworkType_Wifi = 2
};
bool NetworkType_IsValid(int value);
const NetworkType NetworkType_MIN = NetworkType_Unknow;
const NetworkType NetworkType_MAX = NetworkType_Wifi;
const int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

enum YouMeUserRole {
  YOUME_USER_NONE = 0,
  YOUME_USER_TALKER_FREE = 1,
  YOUME_USER_TALKER_ON_DEMAND = 2,
  YOUME_USER_LISTENER = 3,
  YOUME_USER_COMMANDER = 4,
  YOUME_USER_HOST = 5,
  YOUME_USER_GUSET = 6,
  YOUME_USER_DOLL_MACHINE_H5 = 99
};
bool YouMeUserRole_IsValid(int value);
const YouMeUserRole YouMeUserRole_MIN = YOUME_USER_NONE;
const YouMeUserRole YouMeUserRole_MAX = YOUME_USER_DOLL_MACHINE_H5;
const int YouMeUserRole_ARRAYSIZE = YouMeUserRole_MAX + 1;

enum MSG_TYPE {
  MSG_SDK_AUTH = 0,
  MSG_SDK_Logout = 1,
  MSG_LOGIN = 2,
  MSG_CALLBEGIN = 3,
  MSG_CALLEND = 4,
  MSG_LOGOUT = 5,
  MSG_GET_CONFIG = 6,
  MSG_JoinConference = 7,
  MSG_LeaveConference = 8,
  MSG_Heart = 9,
  MSG_DataReport = 10,
  MSG_Kickout = 11,
  MSG_Redirect = 17,
  MSG_UploadLog = 18,
  MSG_CFGSVR_INFO_REQUEST = 12,
  MSG_CFGSVR_INFO_RESPONSE = 13,
  MSG_CFGSVR_WEB_NOTIFY = 14,
  MSG_CFGSVR_HEARTBEAT = 15,
  MSG_CFGSVR_HEARTBEAT_ACK = 16,
  MSG_MIC_STATUS = 19,
  MSG_MIC_STATUS_SERVER = 20,
  MSG_ROOM_MEMBERS_CHANGE = 23,
  MSG_COMMON_STATUS = 24,
  MSG_COMMON_STATUS_SERVER = 25,
  MSG_JOIN_ROOM = 26,
  MSG_JOIN_ROOM_SERVER = 27,
  MSG_LEAVE_ROOM = 28,
  MSG_LEAVE_ROOM_SERVER = 29,
  MSG_SPEAK_TO_ROOM = 30,
  MSG_SPEAK_TO_ROOM_SERVER = 31,
  MSG_MCU_JOIN_LEAVE_ROOM = 32,
  MSG_SESSIONID_TO_USERID = 33,
  MSG_GET_REDIRECT = 34,
  MSG_GET_USER_LIST = 35,
  MSG_GET_USER_LIST_SERVER = 36,
  MSG_USER_JOIN_LEAVE_NOTIFY = 37,
  MSG_FIGHT_4_MIC_INIT = 38,
  MSG_FIGHT_4_MIC_DEINIT = 39,
  MSG_FIGHT_4_MIC = 40,
  MSG_RELEASE_MIC = 41,
  MSG_FIGHT_4_MIC_NOTIFY = 42,
  MSG_INVITE = 43,
  MSG_ACCEPT = 44,
  MSG_INVITE_NOTIFY = 45,
  MSG_INVITE_BYE = 46,
  MSG_INVITE_INIT = 47,
  MSG_MASK_VIDEO_BY_USERID = 48,
  MSG_MASK_VIDEO_BY_USERID_NFY = 49,
  MSG_CAMERA_STATUS = 50,
  MSG_CAMERA_STATUS_NFY = 51,
  MSG_SEND_MESSAGE = 52,
  MSG_SEND_MESSAGE_SERVER = 53,
  MSG_MESSAGE_NOTIFY = 54,
  MSG_SET_SEND_LIST = 55,
  MSG_SET_SEND_LIST_ACK = 56,
  MSG_KICK_USRE = 57,
  MSG_KICK_USRE_ACK = 58,
  MSG_KICK_USRE_NOTIFY = 59,
  MSG_MEDIA_AVINPUT_STAT = 60,
  MSG_MEDIA_AVINPUT_STAT_ACK = 61,
  MSG_MEDIA_AVINPUT_STAT_NOTIFY = 62,
  MSG_KICK_OTHER_NOTIFY = 63,
  MSG_QUERY_USER_VIDEO_INFO = 64,
  MSG_QUERY_USER_VIDEO_INFO_ACK = 65,
  MSG_SET_RECV_VIDEO_INFO = 66,
  MSG_SET_RECV_VIDEO_INFO_ACK = 67,
  MSG_BUSS_REPORT = 68,
  MSG_BUSS_REPORT_ACK = 69,
  MSG_SET_PUSH_SINGLE = 70,
  MSG_SET_PUSH_SINGLE_ACK = 71,
  MSG_REMOVE_PUSH_SINGLE = 72,
  MSG_REMOVE_PUSH_SINGLE_ACK = 73,
  MSG_SET_PUSH_MIX = 74,
  MSG_SET_PUSH_MIX_ACK = 75,
  MSG_CLEAR_PUSH_MIX = 76,
  MSG_CLEAR_PUSH_MIX_ACK = 77,
  MSG_ADD_PUSH_MIX_USER = 78,
  MSG_ADD_PUSH_MIX_USER_ACK = 79,
  MSG_REMOVE_PUSH_MIX_USER = 80,
  MSG_REMOVE_PUSH_MIX_USER_ACK = 81,
  MSG_OTHER_SET_PUSH_MIX = 82,
  MSG_SET_RECV_VIDEO_INFO_NOTIFY = 84
};
bool MSG_TYPE_IsValid(int value);
const MSG_TYPE MSG_TYPE_MIN = MSG_SDK_AUTH;
const MSG_TYPE MSG_TYPE_MAX = MSG_SET_RECV_VIDEO_INFO_NOTIFY;
const int MSG_TYPE_ARRAYSIZE = MSG_TYPE_MAX + 1;

enum STATUS_EVENT_TYPE {
  MIC_STATUS = 0,
  SPEAKER_STATUS = 1,
  MIC_CTR_STATUS = 2,
  SPEAKER_CTR_STATUS = 3,
  AVOID_STATUS = 4,
  IDENTITY_MODIFY = 5
};
bool STATUS_EVENT_TYPE_IsValid(int value);
const STATUS_EVENT_TYPE STATUS_EVENT_TYPE_MIN = MIC_STATUS;
const STATUS_EVENT_TYPE STATUS_EVENT_TYPE_MAX = IDENTITY_MODIFY;
const int STATUS_EVENT_TYPE_ARRAYSIZE = STATUS_EVENT_TYPE_MAX + 1;

enum NAME_TYPE {
  NAME_UNKNOW = 0,
  NAME_INT32 = 1,
  NAME_UIN32 = 2,
  NAME_INT64 = 3,
  NAME_UINT64 = 4,
  NAME_STRING = 5,
  NAME_BYTES = 6,
  NAME_BOOL = 7
};
bool NAME_TYPE_IsValid(int value);
const NAME_TYPE NAME_TYPE_MIN = NAME_UNKNOW;
const NAME_TYPE NAME_TYPE_MAX = NAME_BOOL;
const int NAME_TYPE_ARRAYSIZE = NAME_TYPE_MAX + 1;

// ===================================================================

class PacketHead : public ::youmecommon::protobuf::MessageLite {
 public:
  PacketHead();
  virtual ~PacketHead();

  PacketHead(const PacketHead& from);

  inline PacketHead& operator=(const PacketHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PacketHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PacketHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PacketHead* other);

  // implements Message ----------------------------------------------

  inline PacketHead* New() const { return New(NULL); }

  PacketHead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const PacketHead& from);
  void MergeFrom(const PacketHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PacketHead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.MSG_TYPE msgtype = 1;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  ::YouMeProtocol::MSG_TYPE msgtype() const;
  void set_msgtype(::YouMeProtocol::MSG_TYPE value);

  // required int32 msgversion = 2;
  bool has_msgversion() const;
  void clear_msgversion();
  static const int kMsgversionFieldNumber = 2;
  ::youmecommon::protobuf::int32 msgversion() const;
  void set_msgversion(::youmecommon::protobuf::int32 value);

  // required .YouMeProtocol.Device_Platform platform = 3;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 3;
  ::YouMeProtocol::Device_Platform platform() const;
  void set_platform(::YouMeProtocol::Device_Platform value);

  // optional string Brand = 4;
  bool has_brand() const;
  void clear_brand();
  static const int kBrandFieldNumber = 4;
  const ::std::string& brand() const;
  void set_brand(const ::std::string& value);
  void set_brand(const char* value);
  void set_brand(const char* value, size_t size);
  ::std::string* mutable_brand();
  ::std::string* release_brand();
  void set_allocated_brand(::std::string* brand);

  // optional string SysVersion = 5;
  bool has_sysversion() const;
  void clear_sysversion();
  static const int kSysVersionFieldNumber = 5;
  const ::std::string& sysversion() const;
  void set_sysversion(const ::std::string& value);
  void set_sysversion(const char* value);
  void set_sysversion(const char* value, size_t size);
  ::std::string* mutable_sysversion();
  ::std::string* release_sysversion();
  void set_allocated_sysversion(::std::string* sysversion);

  // optional int32 YmSdkVersion = 6;
  bool has_ymsdkversion() const;
  void clear_ymsdkversion();
  static const int kYmSdkVersionFieldNumber = 6;
  ::youmecommon::protobuf::int32 ymsdkversion() const;
  void set_ymsdkversion(::youmecommon::protobuf::int32 value);

  // optional string CpuArch = 7;
  bool has_cpuarch() const;
  void clear_cpuarch();
  static const int kCpuArchFieldNumber = 7;
  const ::std::string& cpuarch() const;
  void set_cpuarch(const ::std::string& value);
  void set_cpuarch(const char* value);
  void set_cpuarch(const char* value, size_t size);
  ::std::string* mutable_cpuarch();
  ::std::string* release_cpuarch();
  void set_allocated_cpuarch(::std::string* cpuarch);

  // optional string PackageName = 8;
  bool has_packagename() const;
  void clear_packagename();
  static const int kPackageNameFieldNumber = 8;
  const ::std::string& packagename() const;
  void set_packagename(const ::std::string& value);
  void set_packagename(const char* value);
  void set_packagename(const char* value, size_t size);
  ::std::string* mutable_packagename();
  ::std::string* release_packagename();
  void set_allocated_packagename(::std::string* packagename);

  // optional string Identify = 9;
  bool has_identify() const;
  void clear_identify();
  static const int kIdentifyFieldNumber = 9;
  const ::std::string& identify() const;
  void set_identify(const ::std::string& value);
  void set_identify(const char* value);
  void set_identify(const char* value, size_t size);
  ::std::string* mutable_identify();
  ::std::string* release_identify();
  void set_allocated_identify(::std::string* identify);

  // optional string AppKey = 10;
  bool has_appkey() const;
  void clear_appkey();
  static const int kAppKeyFieldNumber = 10;
  const ::std::string& appkey() const;
  void set_appkey(const ::std::string& value);
  void set_appkey(const char* value);
  void set_appkey(const char* value, size_t size);
  ::std::string* mutable_appkey();
  ::std::string* release_appkey();
  void set_allocated_appkey(::std::string* appkey);

  // optional string SDKName = 11;
  bool has_sdkname() const;
  void clear_sdkname();
  static const int kSDKNameFieldNumber = 11;
  const ::std::string& sdkname() const;
  void set_sdkname(const ::std::string& value);
  void set_sdkname(const char* value);
  void set_sdkname(const char* value, size_t size);
  ::std::string* mutable_sdkname();
  ::std::string* release_sdkname();
  void set_allocated_sdkname(::std::string* sdkname);

  // optional string Model = 12;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 12;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // optional .YouMeProtocol.NetworkType NetworkType = 13;
  bool has_networktype() const;
  void clear_networktype();
  static const int kNetworkTypeFieldNumber = 13;
  ::YouMeProtocol::NetworkType networktype() const;
  void set_networktype(::YouMeProtocol::NetworkType value);

  // optional string CPUChip = 14;
  bool has_cpuchip() const;
  void clear_cpuchip();
  static const int kCPUChipFieldNumber = 14;
  const ::std::string& cpuchip() const;
  void set_cpuchip(const ::std::string& value);
  void set_cpuchip(const char* value);
  void set_cpuchip(const char* value, size_t size);
  ::std::string* mutable_cpuchip();
  ::std::string* release_cpuchip();
  void set_allocated_cpuchip(::std::string* cpuchip);

  // optional string UserId = 16;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 16;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // optional uint64 BusinessId = 17;
  bool has_businessid() const;
  void clear_businessid();
  static const int kBusinessIdFieldNumber = 17;
  ::youmecommon::protobuf::uint64 businessid() const;
  void set_businessid(::youmecommon::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.PacketHead)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msgversion();
  inline void clear_has_msgversion();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_brand();
  inline void clear_has_brand();
  inline void set_has_sysversion();
  inline void clear_has_sysversion();
  inline void set_has_ymsdkversion();
  inline void clear_has_ymsdkversion();
  inline void set_has_cpuarch();
  inline void clear_has_cpuarch();
  inline void set_has_packagename();
  inline void clear_has_packagename();
  inline void set_has_identify();
  inline void clear_has_identify();
  inline void set_has_appkey();
  inline void clear_has_appkey();
  inline void set_has_sdkname();
  inline void clear_has_sdkname();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_networktype();
  inline void clear_has_networktype();
  inline void set_has_cpuchip();
  inline void clear_has_cpuchip();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_businessid();
  inline void clear_has_businessid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int msgtype_;
  ::youmecommon::protobuf::int32 msgversion_;
  ::youmecommon::protobuf::internal::ArenaStringPtr brand_;
  int platform_;
  ::youmecommon::protobuf::int32 ymsdkversion_;
  ::youmecommon::protobuf::internal::ArenaStringPtr sysversion_;
  ::youmecommon::protobuf::internal::ArenaStringPtr cpuarch_;
  ::youmecommon::protobuf::internal::ArenaStringPtr packagename_;
  ::youmecommon::protobuf::internal::ArenaStringPtr identify_;
  ::youmecommon::protobuf::internal::ArenaStringPtr appkey_;
  ::youmecommon::protobuf::internal::ArenaStringPtr sdkname_;
  ::youmecommon::protobuf::internal::ArenaStringPtr model_;
  ::youmecommon::protobuf::internal::ArenaStringPtr cpuchip_;
  ::youmecommon::protobuf::internal::ArenaStringPtr userid_;
  ::youmecommon::protobuf::uint64 businessid_;
  int networktype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PacketHead* default_instance_;
};
// -------------------------------------------------------------------

class ReqHead : public ::youmecommon::protobuf::MessageLite {
 public:
  ReqHead();
  virtual ~ReqHead();

  ReqHead(const ReqHead& from);

  inline ReqHead& operator=(const ReqHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReqHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqHead* other);

  // implements Message ----------------------------------------------

  inline ReqHead* New() const { return New(NULL); }

  ReqHead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const ReqHead& from);
  void MergeFrom(const ReqHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReqHead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.PacketHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::YouMeProtocol::PacketHead& head() const;
  ::YouMeProtocol::PacketHead* mutable_head();
  ::YouMeProtocol::PacketHead* release_head();
  void set_allocated_head(::YouMeProtocol::PacketHead* head);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.ReqHead)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::YouMeProtocol::PacketHead* head_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ReqHead* default_instance_;
};
// -------------------------------------------------------------------

class ServerPacketHead : public ::youmecommon::protobuf::MessageLite {
 public:
  ServerPacketHead();
  virtual ~ServerPacketHead();

  ServerPacketHead(const ServerPacketHead& from);

  inline ServerPacketHead& operator=(const ServerPacketHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ServerPacketHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerPacketHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerPacketHead* other);

  // implements Message ----------------------------------------------

  inline ServerPacketHead* New() const { return New(NULL); }

  ServerPacketHead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const ServerPacketHead& from);
  void MergeFrom(const ServerPacketHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerPacketHead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.MSG_TYPE msgtype = 1;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  ::YouMeProtocol::MSG_TYPE msgtype() const;
  void set_msgtype(::YouMeProtocol::MSG_TYPE value);

  // required int32 msgversion = 2;
  bool has_msgversion() const;
  void clear_msgversion();
  static const int kMsgversionFieldNumber = 2;
  ::youmecommon::protobuf::int32 msgversion() const;
  void set_msgversion(::youmecommon::protobuf::int32 value);

  // required int32 code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::youmecommon::protobuf::int32 code() const;
  void set_code(::youmecommon::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.ServerPacketHead)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msgversion();
  inline void clear_has_msgversion();
  inline void set_has_code();
  inline void clear_has_code();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int msgtype_;
  ::youmecommon::protobuf::int32 msgversion_;
  ::youmecommon::protobuf::int32 code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ServerPacketHead* default_instance_;
};
// -------------------------------------------------------------------

class ServerReqHead : public ::youmecommon::protobuf::MessageLite {
 public:
  ServerReqHead();
  virtual ~ServerReqHead();

  ServerReqHead(const ServerReqHead& from);

  inline ServerReqHead& operator=(const ServerReqHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ServerReqHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerReqHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerReqHead* other);

  // implements Message ----------------------------------------------

  inline ServerReqHead* New() const { return New(NULL); }

  ServerReqHead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const ServerReqHead& from);
  void MergeFrom(const ServerReqHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerReqHead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.ServerPacketHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::YouMeProtocol::ServerPacketHead& head() const;
  ::YouMeProtocol::ServerPacketHead* mutable_head();
  ::YouMeProtocol::ServerPacketHead* release_head();
  void set_allocated_head(::YouMeProtocol::ServerPacketHead* head);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.ServerReqHead)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::YouMeProtocol::ServerPacketHead* head_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ServerReqHead* default_instance_;
};
// -------------------------------------------------------------------

class NameValue : public ::youmecommon::protobuf::MessageLite {
 public:
  NameValue();
  virtual ~NameValue();

  NameValue(const NameValue& from);

  inline NameValue& operator=(const NameValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NameValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NameValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NameValue* other);

  // implements Message ----------------------------------------------

  inline NameValue* New() const { return New(NULL); }

  NameValue* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const NameValue& from);
  void MergeFrom(const NameValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NameValue* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // required .YouMeProtocol.NAME_TYPE type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::YouMeProtocol::NAME_TYPE type() const;
  void set_type(::YouMeProtocol::NAME_TYPE value);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.NameValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::internal::ArenaStringPtr name_;
  ::youmecommon::protobuf::internal::ArenaStringPtr value_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NameValue* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PacketHead

// required .YouMeProtocol.MSG_TYPE msgtype = 1;
inline bool PacketHead::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketHead::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketHead::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketHead::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::YouMeProtocol::MSG_TYPE PacketHead::msgtype() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.msgtype)
  return static_cast< ::YouMeProtocol::MSG_TYPE >(msgtype_);
}
inline void PacketHead::set_msgtype(::YouMeProtocol::MSG_TYPE value) {
  assert(::YouMeProtocol::MSG_TYPE_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.msgtype)
}

// required int32 msgversion = 2;
inline bool PacketHead::has_msgversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketHead::set_has_msgversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketHead::clear_has_msgversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketHead::clear_msgversion() {
  msgversion_ = 0;
  clear_has_msgversion();
}
inline ::youmecommon::protobuf::int32 PacketHead::msgversion() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.msgversion)
  return msgversion_;
}
inline void PacketHead::set_msgversion(::youmecommon::protobuf::int32 value) {
  set_has_msgversion();
  msgversion_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.msgversion)
}

// required .YouMeProtocol.Device_Platform platform = 3;
inline bool PacketHead::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PacketHead::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PacketHead::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PacketHead::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::YouMeProtocol::Device_Platform PacketHead::platform() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.platform)
  return static_cast< ::YouMeProtocol::Device_Platform >(platform_);
}
inline void PacketHead::set_platform(::YouMeProtocol::Device_Platform value) {
  assert(::YouMeProtocol::Device_Platform_IsValid(value));
  set_has_platform();
  platform_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.platform)
}

// optional string Brand = 4;
inline bool PacketHead::has_brand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PacketHead::set_has_brand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PacketHead::clear_has_brand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PacketHead::clear_brand() {
  brand_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_brand();
}
inline const ::std::string& PacketHead::brand() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.Brand)
  return brand_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_brand(const ::std::string& value) {
  set_has_brand();
  brand_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.Brand)
}
inline void PacketHead::set_brand(const char* value) {
  set_has_brand();
  brand_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.Brand)
}
inline void PacketHead::set_brand(const char* value, size_t size) {
  set_has_brand();
  brand_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.Brand)
}
inline ::std::string* PacketHead::mutable_brand() {
  set_has_brand();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.Brand)
  return brand_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_brand() {
  clear_has_brand();
  return brand_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_brand(::std::string* brand) {
  if (brand != NULL) {
    set_has_brand();
  } else {
    clear_has_brand();
  }
  brand_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), brand);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.Brand)
}

// optional string SysVersion = 5;
inline bool PacketHead::has_sysversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PacketHead::set_has_sysversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PacketHead::clear_has_sysversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PacketHead::clear_sysversion() {
  sysversion_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sysversion();
}
inline const ::std::string& PacketHead::sysversion() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.SysVersion)
  return sysversion_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_sysversion(const ::std::string& value) {
  set_has_sysversion();
  sysversion_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.SysVersion)
}
inline void PacketHead::set_sysversion(const char* value) {
  set_has_sysversion();
  sysversion_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.SysVersion)
}
inline void PacketHead::set_sysversion(const char* value, size_t size) {
  set_has_sysversion();
  sysversion_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.SysVersion)
}
inline ::std::string* PacketHead::mutable_sysversion() {
  set_has_sysversion();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.SysVersion)
  return sysversion_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_sysversion() {
  clear_has_sysversion();
  return sysversion_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_sysversion(::std::string* sysversion) {
  if (sysversion != NULL) {
    set_has_sysversion();
  } else {
    clear_has_sysversion();
  }
  sysversion_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), sysversion);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.SysVersion)
}

// optional int32 YmSdkVersion = 6;
inline bool PacketHead::has_ymsdkversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PacketHead::set_has_ymsdkversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PacketHead::clear_has_ymsdkversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PacketHead::clear_ymsdkversion() {
  ymsdkversion_ = 0;
  clear_has_ymsdkversion();
}
inline ::youmecommon::protobuf::int32 PacketHead::ymsdkversion() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.YmSdkVersion)
  return ymsdkversion_;
}
inline void PacketHead::set_ymsdkversion(::youmecommon::protobuf::int32 value) {
  set_has_ymsdkversion();
  ymsdkversion_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.YmSdkVersion)
}

// optional string CpuArch = 7;
inline bool PacketHead::has_cpuarch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PacketHead::set_has_cpuarch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PacketHead::clear_has_cpuarch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PacketHead::clear_cpuarch() {
  cpuarch_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cpuarch();
}
inline const ::std::string& PacketHead::cpuarch() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.CpuArch)
  return cpuarch_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_cpuarch(const ::std::string& value) {
  set_has_cpuarch();
  cpuarch_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.CpuArch)
}
inline void PacketHead::set_cpuarch(const char* value) {
  set_has_cpuarch();
  cpuarch_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.CpuArch)
}
inline void PacketHead::set_cpuarch(const char* value, size_t size) {
  set_has_cpuarch();
  cpuarch_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.CpuArch)
}
inline ::std::string* PacketHead::mutable_cpuarch() {
  set_has_cpuarch();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.CpuArch)
  return cpuarch_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_cpuarch() {
  clear_has_cpuarch();
  return cpuarch_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_cpuarch(::std::string* cpuarch) {
  if (cpuarch != NULL) {
    set_has_cpuarch();
  } else {
    clear_has_cpuarch();
  }
  cpuarch_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), cpuarch);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.CpuArch)
}

// optional string PackageName = 8;
inline bool PacketHead::has_packagename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PacketHead::set_has_packagename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PacketHead::clear_has_packagename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PacketHead::clear_packagename() {
  packagename_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packagename();
}
inline const ::std::string& PacketHead::packagename() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.PackageName)
  return packagename_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_packagename(const ::std::string& value) {
  set_has_packagename();
  packagename_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.PackageName)
}
inline void PacketHead::set_packagename(const char* value) {
  set_has_packagename();
  packagename_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.PackageName)
}
inline void PacketHead::set_packagename(const char* value, size_t size) {
  set_has_packagename();
  packagename_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.PackageName)
}
inline ::std::string* PacketHead::mutable_packagename() {
  set_has_packagename();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.PackageName)
  return packagename_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_packagename() {
  clear_has_packagename();
  return packagename_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_packagename(::std::string* packagename) {
  if (packagename != NULL) {
    set_has_packagename();
  } else {
    clear_has_packagename();
  }
  packagename_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), packagename);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.PackageName)
}

// optional string Identify = 9;
inline bool PacketHead::has_identify() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PacketHead::set_has_identify() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PacketHead::clear_has_identify() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PacketHead::clear_identify() {
  identify_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identify();
}
inline const ::std::string& PacketHead::identify() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.Identify)
  return identify_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_identify(const ::std::string& value) {
  set_has_identify();
  identify_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.Identify)
}
inline void PacketHead::set_identify(const char* value) {
  set_has_identify();
  identify_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.Identify)
}
inline void PacketHead::set_identify(const char* value, size_t size) {
  set_has_identify();
  identify_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.Identify)
}
inline ::std::string* PacketHead::mutable_identify() {
  set_has_identify();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.Identify)
  return identify_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_identify() {
  clear_has_identify();
  return identify_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_identify(::std::string* identify) {
  if (identify != NULL) {
    set_has_identify();
  } else {
    clear_has_identify();
  }
  identify_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), identify);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.Identify)
}

// optional string AppKey = 10;
inline bool PacketHead::has_appkey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PacketHead::set_has_appkey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PacketHead::clear_has_appkey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PacketHead::clear_appkey() {
  appkey_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_appkey();
}
inline const ::std::string& PacketHead::appkey() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.AppKey)
  return appkey_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_appkey(const ::std::string& value) {
  set_has_appkey();
  appkey_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.AppKey)
}
inline void PacketHead::set_appkey(const char* value) {
  set_has_appkey();
  appkey_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.AppKey)
}
inline void PacketHead::set_appkey(const char* value, size_t size) {
  set_has_appkey();
  appkey_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.AppKey)
}
inline ::std::string* PacketHead::mutable_appkey() {
  set_has_appkey();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.AppKey)
  return appkey_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_appkey() {
  clear_has_appkey();
  return appkey_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_appkey(::std::string* appkey) {
  if (appkey != NULL) {
    set_has_appkey();
  } else {
    clear_has_appkey();
  }
  appkey_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), appkey);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.AppKey)
}

// optional string SDKName = 11;
inline bool PacketHead::has_sdkname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PacketHead::set_has_sdkname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PacketHead::clear_has_sdkname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PacketHead::clear_sdkname() {
  sdkname_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdkname();
}
inline const ::std::string& PacketHead::sdkname() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.SDKName)
  return sdkname_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_sdkname(const ::std::string& value) {
  set_has_sdkname();
  sdkname_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.SDKName)
}
inline void PacketHead::set_sdkname(const char* value) {
  set_has_sdkname();
  sdkname_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.SDKName)
}
inline void PacketHead::set_sdkname(const char* value, size_t size) {
  set_has_sdkname();
  sdkname_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.SDKName)
}
inline ::std::string* PacketHead::mutable_sdkname() {
  set_has_sdkname();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.SDKName)
  return sdkname_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_sdkname() {
  clear_has_sdkname();
  return sdkname_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_sdkname(::std::string* sdkname) {
  if (sdkname != NULL) {
    set_has_sdkname();
  } else {
    clear_has_sdkname();
  }
  sdkname_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), sdkname);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.SDKName)
}

// optional string Model = 12;
inline bool PacketHead::has_model() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PacketHead::set_has_model() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PacketHead::clear_has_model() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PacketHead::clear_model() {
  model_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model();
}
inline const ::std::string& PacketHead::model() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.Model)
  return model_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_model(const ::std::string& value) {
  set_has_model();
  model_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.Model)
}
inline void PacketHead::set_model(const char* value) {
  set_has_model();
  model_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.Model)
}
inline void PacketHead::set_model(const char* value, size_t size) {
  set_has_model();
  model_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.Model)
}
inline ::std::string* PacketHead::mutable_model() {
  set_has_model();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.Model)
  return model_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_model() {
  clear_has_model();
  return model_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    set_has_model();
  } else {
    clear_has_model();
  }
  model_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.Model)
}

// optional .YouMeProtocol.NetworkType NetworkType = 13;
inline bool PacketHead::has_networktype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PacketHead::set_has_networktype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PacketHead::clear_has_networktype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PacketHead::clear_networktype() {
  networktype_ = 0;
  clear_has_networktype();
}
inline ::YouMeProtocol::NetworkType PacketHead::networktype() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.NetworkType)
  return static_cast< ::YouMeProtocol::NetworkType >(networktype_);
}
inline void PacketHead::set_networktype(::YouMeProtocol::NetworkType value) {
  assert(::YouMeProtocol::NetworkType_IsValid(value));
  set_has_networktype();
  networktype_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.NetworkType)
}

// optional string CPUChip = 14;
inline bool PacketHead::has_cpuchip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PacketHead::set_has_cpuchip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PacketHead::clear_has_cpuchip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PacketHead::clear_cpuchip() {
  cpuchip_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cpuchip();
}
inline const ::std::string& PacketHead::cpuchip() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.CPUChip)
  return cpuchip_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_cpuchip(const ::std::string& value) {
  set_has_cpuchip();
  cpuchip_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.CPUChip)
}
inline void PacketHead::set_cpuchip(const char* value) {
  set_has_cpuchip();
  cpuchip_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.CPUChip)
}
inline void PacketHead::set_cpuchip(const char* value, size_t size) {
  set_has_cpuchip();
  cpuchip_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.CPUChip)
}
inline ::std::string* PacketHead::mutable_cpuchip() {
  set_has_cpuchip();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.CPUChip)
  return cpuchip_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_cpuchip() {
  clear_has_cpuchip();
  return cpuchip_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_cpuchip(::std::string* cpuchip) {
  if (cpuchip != NULL) {
    set_has_cpuchip();
  } else {
    clear_has_cpuchip();
  }
  cpuchip_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), cpuchip);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.CPUChip)
}

// optional string UserId = 16;
inline bool PacketHead::has_userid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PacketHead::set_has_userid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PacketHead::clear_has_userid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PacketHead::clear_userid() {
  userid_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& PacketHead::userid() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.UserId)
  return userid_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.UserId)
}
inline void PacketHead::set_userid(const char* value) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.PacketHead.UserId)
}
inline void PacketHead::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.PacketHead.UserId)
}
inline ::std::string* PacketHead::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.PacketHead.UserId)
  return userid_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PacketHead::release_userid() {
  clear_has_userid();
  return userid_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PacketHead::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.PacketHead.UserId)
}

// optional uint64 BusinessId = 17;
inline bool PacketHead::has_businessid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PacketHead::set_has_businessid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PacketHead::clear_has_businessid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PacketHead::clear_businessid() {
  businessid_ = GOOGLE_ULONGLONG(0);
  clear_has_businessid();
}
inline ::youmecommon::protobuf::uint64 PacketHead::businessid() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.PacketHead.BusinessId)
  return businessid_;
}
inline void PacketHead::set_businessid(::youmecommon::protobuf::uint64 value) {
  set_has_businessid();
  businessid_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.PacketHead.BusinessId)
}

// -------------------------------------------------------------------

// ReqHead

// required .YouMeProtocol.PacketHead head = 1;
inline bool ReqHead::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHead::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHead::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHead::clear_head() {
  if (head_ != NULL) head_->::YouMeProtocol::PacketHead::Clear();
  clear_has_head();
}
inline const ::YouMeProtocol::PacketHead& ReqHead::head() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.ReqHead.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::YouMeProtocol::PacketHead* ReqHead::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::YouMeProtocol::PacketHead;
  }
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.ReqHead.head)
  return head_;
}
inline ::YouMeProtocol::PacketHead* ReqHead::release_head() {
  clear_has_head();
  ::YouMeProtocol::PacketHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void ReqHead::set_allocated_head(::YouMeProtocol::PacketHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.ReqHead.head)
}

// -------------------------------------------------------------------

// ServerPacketHead

// required .YouMeProtocol.MSG_TYPE msgtype = 1;
inline bool ServerPacketHead::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerPacketHead::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerPacketHead::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerPacketHead::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::YouMeProtocol::MSG_TYPE ServerPacketHead::msgtype() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.ServerPacketHead.msgtype)
  return static_cast< ::YouMeProtocol::MSG_TYPE >(msgtype_);
}
inline void ServerPacketHead::set_msgtype(::YouMeProtocol::MSG_TYPE value) {
  assert(::YouMeProtocol::MSG_TYPE_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.ServerPacketHead.msgtype)
}

// required int32 msgversion = 2;
inline bool ServerPacketHead::has_msgversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerPacketHead::set_has_msgversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerPacketHead::clear_has_msgversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerPacketHead::clear_msgversion() {
  msgversion_ = 0;
  clear_has_msgversion();
}
inline ::youmecommon::protobuf::int32 ServerPacketHead::msgversion() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.ServerPacketHead.msgversion)
  return msgversion_;
}
inline void ServerPacketHead::set_msgversion(::youmecommon::protobuf::int32 value) {
  set_has_msgversion();
  msgversion_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.ServerPacketHead.msgversion)
}

// required int32 code = 3;
inline bool ServerPacketHead::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerPacketHead::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerPacketHead::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerPacketHead::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::youmecommon::protobuf::int32 ServerPacketHead::code() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.ServerPacketHead.code)
  return code_;
}
inline void ServerPacketHead::set_code(::youmecommon::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.ServerPacketHead.code)
}

// -------------------------------------------------------------------

// ServerReqHead

// required .YouMeProtocol.ServerPacketHead head = 1;
inline bool ServerReqHead::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerReqHead::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerReqHead::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerReqHead::clear_head() {
  if (head_ != NULL) head_->::YouMeProtocol::ServerPacketHead::Clear();
  clear_has_head();
}
inline const ::YouMeProtocol::ServerPacketHead& ServerReqHead::head() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.ServerReqHead.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::YouMeProtocol::ServerPacketHead* ServerReqHead::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::YouMeProtocol::ServerPacketHead;
  }
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.ServerReqHead.head)
  return head_;
}
inline ::YouMeProtocol::ServerPacketHead* ServerReqHead::release_head() {
  clear_has_head();
  ::YouMeProtocol::ServerPacketHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void ServerReqHead::set_allocated_head(::YouMeProtocol::ServerPacketHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.ServerReqHead.head)
}

// -------------------------------------------------------------------

// NameValue

// required string name = 1;
inline bool NameValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValue::clear_name() {
  name_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NameValue::name() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.NameValue.name)
  return name_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NameValue::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.NameValue.name)
}
inline void NameValue::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.NameValue.name)
}
inline void NameValue::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.NameValue.name)
}
inline ::std::string* NameValue::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.NameValue.name)
  return name_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NameValue::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NameValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.NameValue.name)
}

// required string value = 2;
inline bool NameValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValue::clear_value() {
  value_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& NameValue::value() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.NameValue.value)
  return value_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NameValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.NameValue.value)
}
inline void NameValue::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.NameValue.value)
}
inline void NameValue::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.NameValue.value)
}
inline ::std::string* NameValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.NameValue.value)
  return value_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NameValue::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NameValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.NameValue.value)
}

// required .YouMeProtocol.NAME_TYPE type = 3;
inline bool NameValue::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameValue::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::YouMeProtocol::NAME_TYPE NameValue::type() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.NameValue.type)
  return static_cast< ::YouMeProtocol::NAME_TYPE >(type_);
}
inline void NameValue::set_type(::YouMeProtocol::NAME_TYPE value) {
  assert(::YouMeProtocol::NAME_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.NameValue.type)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace YouMeProtocol

#ifndef SWIG
namespace youmecommon {
namespace protobuf {

template <> struct is_proto_enum< ::YouMeProtocol::Device_Platform> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::NetworkType> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::YouMeUserRole> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::MSG_TYPE> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::STATUS_EVENT_TYPE> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::NAME_TYPE> : ::youmecommon::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace youmecommon
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
