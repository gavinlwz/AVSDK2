// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: YoumeRunningState.proto

#ifndef PROTOBUF_YoumeRunningState_2eproto__INCLUDED
#define PROTOBUF_YoumeRunningState_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace YouMeProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_YoumeRunningState_2eproto();
void protobuf_AssignDesc_YoumeRunningState_2eproto();
void protobuf_ShutdownFile_YoumeRunningState_2eproto();

class DataReportBase;
class DataReportReqHead;
class DataReport_Response;

enum UserEvt {
  Evt_Init_Start = 0,
  Evt_Init_End = 1,
  Evt_SDKValid_Start = 2,
  Evt_SDKValid_End = 3,
  Evt_Redirect_Start = 4,
  Evt_Redirect_End = 5,
  Evt_Join_Room_Start = 6,
  Evt_Join_Room_End = 7,
  Evt_Leave_Room = 8,
  Evt_UnInit = 9,
  Evt_PacketStatus = 10,
  Evt_SDKDNSParse = 11,
  Evt_RecordError = 12,
  Evt_PacketStatMultiUsers = 13
};
bool UserEvt_IsValid(int value);
const UserEvt UserEvt_MIN = Evt_Init_Start;
const UserEvt UserEvt_MAX = Evt_PacketStatMultiUsers;
const int UserEvt_ARRAYSIZE = UserEvt_MAX + 1;

enum RecordErrCode {
  RecErr_OK = 0,
  RecErr_No_Permission = 1,
  RecErr_No_Data = 2,
  RecErr_Others = 15
};
bool RecordErrCode_IsValid(int value);
const RecordErrCode RecordErrCode_MIN = RecErr_OK;
const RecordErrCode RecordErrCode_MAX = RecErr_Others;
const int RecordErrCode_ARRAYSIZE = RecordErrCode_MAX + 1;

// ===================================================================

class DataReportBase : public ::youmecommon::protobuf::MessageLite {
 public:
  DataReportBase();
  virtual ~DataReportBase();

  DataReportBase(const DataReportBase& from);

  inline DataReportBase& operator=(const DataReportBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataReportBase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataReportBase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataReportBase* other);

  // implements Message ----------------------------------------------

  inline DataReportBase* New() const { return New(NULL); }

  DataReportBase* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const DataReportBase& from);
  void MergeFrom(const DataReportBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataReportBase* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.PacketHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::YouMeProtocol::PacketHead& head() const;
  ::YouMeProtocol::PacketHead* mutable_head();
  ::YouMeProtocol::PacketHead* release_head();
  void set_allocated_head(::YouMeProtocol::PacketHead* head);

  // required .YouMeProtocol.UserEvt evt = 2;
  bool has_evt() const;
  void clear_evt();
  static const int kEvtFieldNumber = 2;
  ::YouMeProtocol::UserEvt evt() const;
  void set_evt(::YouMeProtocol::UserEvt value);

  // optional int32 code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::youmecommon::protobuf::int32 code() const;
  void set_code(::youmecommon::protobuf::int32 value);

  // optional int64 reporttime = 4;
  bool has_reporttime() const;
  void clear_reporttime();
  static const int kReporttimeFieldNumber = 4;
  ::youmecommon::protobuf::int64 reporttime() const;
  void set_reporttime(::youmecommon::protobuf::int64 value);

  // optional string userid = 5;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 5;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.DataReportBase)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_evt();
  inline void clear_has_evt();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_reporttime();
  inline void clear_has_reporttime();
  inline void set_has_userid();
  inline void clear_has_userid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::YouMeProtocol::PacketHead* head_;
  int evt_;
  ::youmecommon::protobuf::int32 code_;
  ::youmecommon::protobuf::int64 reporttime_;
  ::youmecommon::protobuf::internal::ArenaStringPtr userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto();
  #endif
  friend void protobuf_AssignDesc_YoumeRunningState_2eproto();
  friend void protobuf_ShutdownFile_YoumeRunningState_2eproto();

  void InitAsDefaultInstance();
  static DataReportBase* default_instance_;
};
// -------------------------------------------------------------------

class DataReportReqHead : public ::youmecommon::protobuf::MessageLite {
 public:
  DataReportReqHead();
  virtual ~DataReportReqHead();

  DataReportReqHead(const DataReportReqHead& from);

  inline DataReportReqHead& operator=(const DataReportReqHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataReportReqHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataReportReqHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataReportReqHead* other);

  // implements Message ----------------------------------------------

  inline DataReportReqHead* New() const { return New(NULL); }

  DataReportReqHead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const DataReportReqHead& from);
  void MergeFrom(const DataReportReqHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataReportReqHead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .YouMeProtocol.DataReportBase head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::YouMeProtocol::DataReportBase& head() const;
  ::YouMeProtocol::DataReportBase* mutable_head();
  ::YouMeProtocol::DataReportBase* release_head();
  void set_allocated_head(::YouMeProtocol::DataReportBase* head);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.DataReportReqHead)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::YouMeProtocol::DataReportBase* head_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto();
  #endif
  friend void protobuf_AssignDesc_YoumeRunningState_2eproto();
  friend void protobuf_ShutdownFile_YoumeRunningState_2eproto();

  void InitAsDefaultInstance();
  static DataReportReqHead* default_instance_;
};
// -------------------------------------------------------------------

class DataReport_Response : public ::youmecommon::protobuf::MessageLite {
 public:
  DataReport_Response();
  virtual ~DataReport_Response();

  DataReport_Response(const DataReport_Response& from);

  inline DataReport_Response& operator=(const DataReport_Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataReport_Response& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataReport_Response* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataReport_Response* other);

  // implements Message ----------------------------------------------

  inline DataReport_Response* New() const { return New(NULL); }

  DataReport_Response* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const DataReport_Response& from);
  void MergeFrom(const DataReport_Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataReport_Response* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::youmecommon::protobuf::int32 code() const;
  void set_code(::youmecommon::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:YouMeProtocol.DataReport_Response)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::int32 code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_YoumeRunningState_2eproto();
  #endif
  friend void protobuf_AssignDesc_YoumeRunningState_2eproto();
  friend void protobuf_ShutdownFile_YoumeRunningState_2eproto();

  void InitAsDefaultInstance();
  static DataReport_Response* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataReportBase

// required .YouMeProtocol.PacketHead head = 1;
inline bool DataReportBase::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataReportBase::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataReportBase::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataReportBase::clear_head() {
  if (head_ != NULL) head_->::YouMeProtocol::PacketHead::Clear();
  clear_has_head();
}
inline const ::YouMeProtocol::PacketHead& DataReportBase::head() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportBase.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::YouMeProtocol::PacketHead* DataReportBase::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::YouMeProtocol::PacketHead;
  }
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.DataReportBase.head)
  return head_;
}
inline ::YouMeProtocol::PacketHead* DataReportBase::release_head() {
  clear_has_head();
  ::YouMeProtocol::PacketHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void DataReportBase::set_allocated_head(::YouMeProtocol::PacketHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.DataReportBase.head)
}

// required .YouMeProtocol.UserEvt evt = 2;
inline bool DataReportBase::has_evt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataReportBase::set_has_evt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataReportBase::clear_has_evt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataReportBase::clear_evt() {
  evt_ = 0;
  clear_has_evt();
}
inline ::YouMeProtocol::UserEvt DataReportBase::evt() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportBase.evt)
  return static_cast< ::YouMeProtocol::UserEvt >(evt_);
}
inline void DataReportBase::set_evt(::YouMeProtocol::UserEvt value) {
  assert(::YouMeProtocol::UserEvt_IsValid(value));
  set_has_evt();
  evt_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.DataReportBase.evt)
}

// optional int32 code = 3;
inline bool DataReportBase::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataReportBase::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataReportBase::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataReportBase::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::youmecommon::protobuf::int32 DataReportBase::code() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportBase.code)
  return code_;
}
inline void DataReportBase::set_code(::youmecommon::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.DataReportBase.code)
}

// optional int64 reporttime = 4;
inline bool DataReportBase::has_reporttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataReportBase::set_has_reporttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataReportBase::clear_has_reporttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataReportBase::clear_reporttime() {
  reporttime_ = GOOGLE_LONGLONG(0);
  clear_has_reporttime();
}
inline ::youmecommon::protobuf::int64 DataReportBase::reporttime() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportBase.reporttime)
  return reporttime_;
}
inline void DataReportBase::set_reporttime(::youmecommon::protobuf::int64 value) {
  set_has_reporttime();
  reporttime_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.DataReportBase.reporttime)
}

// optional string userid = 5;
inline bool DataReportBase::has_userid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataReportBase::set_has_userid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataReportBase::clear_has_userid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataReportBase::clear_userid() {
  userid_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& DataReportBase::userid() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportBase.userid)
  return userid_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataReportBase::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:YouMeProtocol.DataReportBase.userid)
}
inline void DataReportBase::set_userid(const char* value) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:YouMeProtocol.DataReportBase.userid)
}
inline void DataReportBase::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:YouMeProtocol.DataReportBase.userid)
}
inline ::std::string* DataReportBase::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.DataReportBase.userid)
  return userid_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataReportBase::release_userid() {
  clear_has_userid();
  return userid_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataReportBase::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.DataReportBase.userid)
}

// -------------------------------------------------------------------

// DataReportReqHead

// required .YouMeProtocol.DataReportBase head = 1;
inline bool DataReportReqHead::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataReportReqHead::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataReportReqHead::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataReportReqHead::clear_head() {
  if (head_ != NULL) head_->::YouMeProtocol::DataReportBase::Clear();
  clear_has_head();
}
inline const ::YouMeProtocol::DataReportBase& DataReportReqHead::head() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReportReqHead.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::YouMeProtocol::DataReportBase* DataReportReqHead::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::YouMeProtocol::DataReportBase;
  }
  // @@protoc_insertion_point(field_mutable:YouMeProtocol.DataReportReqHead.head)
  return head_;
}
inline ::YouMeProtocol::DataReportBase* DataReportReqHead::release_head() {
  clear_has_head();
  ::YouMeProtocol::DataReportBase* temp = head_;
  head_ = NULL;
  return temp;
}
inline void DataReportReqHead::set_allocated_head(::YouMeProtocol::DataReportBase* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:YouMeProtocol.DataReportReqHead.head)
}

// -------------------------------------------------------------------

// DataReport_Response

// required int32 code = 1;
inline bool DataReport_Response::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataReport_Response::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataReport_Response::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataReport_Response::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::youmecommon::protobuf::int32 DataReport_Response::code() const {
  // @@protoc_insertion_point(field_get:YouMeProtocol.DataReport_Response.code)
  return code_;
}
inline void DataReport_Response::set_code(::youmecommon::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:YouMeProtocol.DataReport_Response.code)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace YouMeProtocol

#ifndef SWIG
namespace youmecommon {
namespace protobuf {

template <> struct is_proto_enum< ::YouMeProtocol::UserEvt> : ::youmecommon::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::YouMeProtocol::RecordErrCode> : ::youmecommon::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace youmecommon
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_YoumeRunningState_2eproto__INCLUDED
