// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fec.proto

#ifndef PROTOBUF_fec_2eproto__INCLUDED
#define PROTOBUF_fec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace youmecommon {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_fec_2eproto();
void protobuf_AssignDesc_fec_2eproto();
void protobuf_ShutdownFile_fec_2eproto();

class commonhead;
class commonheadpacket;
class fechead;
class fecpacket;
class jitterbufferhead;
class jitterbufferpacket;
class kcphead;
class kcppacket;

enum packettype {
  packettype_unknow = 0,
  packettype_kcp = 1,
  packettype_fec = 2,
  packettype_jit = 3
};
bool packettype_IsValid(int value);
const packettype packettype_MIN = packettype_unknow;
const packettype packettype_MAX = packettype_jit;
const int packettype_ARRAYSIZE = packettype_MAX + 1;

// ===================================================================

class commonheadpacket : public ::youmecommon::protobuf::MessageLite {
 public:
  commonheadpacket();
  virtual ~commonheadpacket();

  commonheadpacket(const commonheadpacket& from);

  inline commonheadpacket& operator=(const commonheadpacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const commonheadpacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const commonheadpacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(commonheadpacket* other);

  // implements Message ----------------------------------------------

  inline commonheadpacket* New() const { return New(NULL); }

  commonheadpacket* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const commonheadpacket& from);
  void MergeFrom(const commonheadpacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(commonheadpacket* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .youmecommon.commonhead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::youmecommon::commonhead& head() const;
  ::youmecommon::commonhead* mutable_head();
  ::youmecommon::commonhead* release_head();
  void set_allocated_head(::youmecommon::commonhead* head);

  // @@protoc_insertion_point(class_scope:youmecommon.commonheadpacket)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::commonhead* head_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static commonheadpacket* default_instance_;
};
// -------------------------------------------------------------------

class commonhead : public ::youmecommon::protobuf::MessageLite {
 public:
  commonhead();
  virtual ~commonhead();

  commonhead(const commonhead& from);

  inline commonhead& operator=(const commonhead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const commonhead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const commonhead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(commonhead* other);

  // implements Message ----------------------------------------------

  inline commonhead* New() const { return New(NULL); }

  commonhead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const commonhead& from);
  void MergeFrom(const commonhead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(commonhead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iVer = 1;
  bool has_iver() const;
  void clear_iver();
  static const int kIVerFieldNumber = 1;
  ::youmecommon::protobuf::int32 iver() const;
  void set_iver(::youmecommon::protobuf::int32 value);

  // required .youmecommon.packettype type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::youmecommon::packettype type() const;
  void set_type(::youmecommon::packettype value);

  // @@protoc_insertion_point(class_scope:youmecommon.commonhead)
 private:
  inline void set_has_iver();
  inline void clear_has_iver();
  inline void set_has_type();
  inline void clear_has_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::int32 iver_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static commonhead* default_instance_;
};
// -------------------------------------------------------------------

class fechead : public ::youmecommon::protobuf::MessageLite {
 public:
  fechead();
  virtual ~fechead();

  fechead(const fechead& from);

  inline fechead& operator=(const fechead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const fechead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fechead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fechead* other);

  // implements Message ----------------------------------------------

  inline fechead* New() const { return New(NULL); }

  fechead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const fechead& from);
  void MergeFrom(const fechead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(fechead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iVer = 1;
  bool has_iver() const;
  void clear_iver();
  static const int kIVerFieldNumber = 1;
  ::youmecommon::protobuf::int32 iver() const;
  void set_iver(::youmecommon::protobuf::int32 value);

  // required int32 iConv = 2;
  bool has_iconv() const;
  void clear_iconv();
  static const int kIConvFieldNumber = 2;
  ::youmecommon::protobuf::int32 iconv() const;
  void set_iconv(::youmecommon::protobuf::int32 value);

  // required int32 iGroupSerial = 3;
  bool has_igroupserial() const;
  void clear_igroupserial();
  static const int kIGroupSerialFieldNumber = 3;
  ::youmecommon::protobuf::int32 igroupserial() const;
  void set_igroupserial(::youmecommon::protobuf::int32 value);

  // required int32 iGroupItemSerial = 4;
  bool has_igroupitemserial() const;
  void clear_igroupitemserial();
  static const int kIGroupItemSerialFieldNumber = 4;
  ::youmecommon::protobuf::int32 igroupitemserial() const;
  void set_igroupitemserial(::youmecommon::protobuf::int32 value);

  // required int32 iType = 5;
  bool has_itype() const;
  void clear_itype();
  static const int kITypeFieldNumber = 5;
  ::youmecommon::protobuf::int32 itype() const;
  void set_itype(::youmecommon::protobuf::int32 value);

  // required int32 iK = 6;
  bool has_ik() const;
  void clear_ik();
  static const int kIKFieldNumber = 6;
  ::youmecommon::protobuf::int32 ik() const;
  void set_ik(::youmecommon::protobuf::int32 value);

  // required int32 iN = 7;
  bool has_in() const;
  void clear_in();
  static const int kINFieldNumber = 7;
  ::youmecommon::protobuf::int32 in() const;
  void set_in(::youmecommon::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:youmecommon.fechead)
 private:
  inline void set_has_iver();
  inline void clear_has_iver();
  inline void set_has_iconv();
  inline void clear_has_iconv();
  inline void set_has_igroupserial();
  inline void clear_has_igroupserial();
  inline void set_has_igroupitemserial();
  inline void clear_has_igroupitemserial();
  inline void set_has_itype();
  inline void clear_has_itype();
  inline void set_has_ik();
  inline void clear_has_ik();
  inline void set_has_in();
  inline void clear_has_in();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::int32 iver_;
  ::youmecommon::protobuf::int32 iconv_;
  ::youmecommon::protobuf::int32 igroupserial_;
  ::youmecommon::protobuf::int32 igroupitemserial_;
  ::youmecommon::protobuf::int32 itype_;
  ::youmecommon::protobuf::int32 ik_;
  ::youmecommon::protobuf::int32 in_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static fechead* default_instance_;
};
// -------------------------------------------------------------------

class kcphead : public ::youmecommon::protobuf::MessageLite {
 public:
  kcphead();
  virtual ~kcphead();

  kcphead(const kcphead& from);

  inline kcphead& operator=(const kcphead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const kcphead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const kcphead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(kcphead* other);

  // implements Message ----------------------------------------------

  inline kcphead* New() const { return New(NULL); }

  kcphead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const kcphead& from);
  void MergeFrom(const kcphead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(kcphead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iVer = 1;
  bool has_iver() const;
  void clear_iver();
  static const int kIVerFieldNumber = 1;
  ::youmecommon::protobuf::int32 iver() const;
  void set_iver(::youmecommon::protobuf::int32 value);

  // required int32 iConv = 2;
  bool has_iconv() const;
  void clear_iconv();
  static const int kIConvFieldNumber = 2;
  ::youmecommon::protobuf::int32 iconv() const;
  void set_iconv(::youmecommon::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:youmecommon.kcphead)
 private:
  inline void set_has_iver();
  inline void clear_has_iver();
  inline void set_has_iconv();
  inline void clear_has_iconv();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::int32 iver_;
  ::youmecommon::protobuf::int32 iconv_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static kcphead* default_instance_;
};
// -------------------------------------------------------------------

class kcppacket : public ::youmecommon::protobuf::MessageLite {
 public:
  kcppacket();
  virtual ~kcppacket();

  kcppacket(const kcppacket& from);

  inline kcppacket& operator=(const kcppacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const kcppacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const kcppacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(kcppacket* other);

  // implements Message ----------------------------------------------

  inline kcppacket* New() const { return New(NULL); }

  kcppacket* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const kcppacket& from);
  void MergeFrom(const kcppacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(kcppacket* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .youmecommon.commonhead comhead = 1;
  bool has_comhead() const;
  void clear_comhead();
  static const int kComheadFieldNumber = 1;
  const ::youmecommon::commonhead& comhead() const;
  ::youmecommon::commonhead* mutable_comhead();
  ::youmecommon::commonhead* release_comhead();
  void set_allocated_comhead(::youmecommon::commonhead* comhead);

  // required .youmecommon.kcphead head = 2;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  const ::youmecommon::kcphead& head() const;
  ::youmecommon::kcphead* mutable_head();
  ::youmecommon::kcphead* release_head();
  void set_allocated_head(::youmecommon::kcphead* head);

  // required bytes payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:youmecommon.kcppacket)
 private:
  inline void set_has_comhead();
  inline void clear_has_comhead();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::commonhead* comhead_;
  ::youmecommon::kcphead* head_;
  ::youmecommon::protobuf::internal::ArenaStringPtr payload_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static kcppacket* default_instance_;
};
// -------------------------------------------------------------------

class fecpacket : public ::youmecommon::protobuf::MessageLite {
 public:
  fecpacket();
  virtual ~fecpacket();

  fecpacket(const fecpacket& from);

  inline fecpacket& operator=(const fecpacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const fecpacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fecpacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fecpacket* other);

  // implements Message ----------------------------------------------

  inline fecpacket* New() const { return New(NULL); }

  fecpacket* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const fecpacket& from);
  void MergeFrom(const fecpacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(fecpacket* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .youmecommon.commonhead comhead = 1;
  bool has_comhead() const;
  void clear_comhead();
  static const int kComheadFieldNumber = 1;
  const ::youmecommon::commonhead& comhead() const;
  ::youmecommon::commonhead* mutable_comhead();
  ::youmecommon::commonhead* release_comhead();
  void set_allocated_comhead(::youmecommon::commonhead* comhead);

  // required .youmecommon.fechead head = 2;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  const ::youmecommon::fechead& head() const;
  ::youmecommon::fechead* mutable_head();
  ::youmecommon::fechead* release_head();
  void set_allocated_head(::youmecommon::fechead* head);

  // required bytes payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:youmecommon.fecpacket)
 private:
  inline void set_has_comhead();
  inline void clear_has_comhead();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::commonhead* comhead_;
  ::youmecommon::fechead* head_;
  ::youmecommon::protobuf::internal::ArenaStringPtr payload_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static fecpacket* default_instance_;
};
// -------------------------------------------------------------------

class jitterbufferhead : public ::youmecommon::protobuf::MessageLite {
 public:
  jitterbufferhead();
  virtual ~jitterbufferhead();

  jitterbufferhead(const jitterbufferhead& from);

  inline jitterbufferhead& operator=(const jitterbufferhead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const jitterbufferhead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const jitterbufferhead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(jitterbufferhead* other);

  // implements Message ----------------------------------------------

  inline jitterbufferhead* New() const { return New(NULL); }

  jitterbufferhead* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const jitterbufferhead& from);
  void MergeFrom(const jitterbufferhead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(jitterbufferhead* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iVer = 1;
  bool has_iver() const;
  void clear_iver();
  static const int kIVerFieldNumber = 1;
  ::youmecommon::protobuf::int32 iver() const;
  void set_iver(::youmecommon::protobuf::int32 value);

  // required int32 iConv = 2;
  bool has_iconv() const;
  void clear_iconv();
  static const int kIConvFieldNumber = 2;
  ::youmecommon::protobuf::int32 iconv() const;
  void set_iconv(::youmecommon::protobuf::int32 value);

  // required int32 iPacketSerial = 3;
  bool has_ipacketserial() const;
  void clear_ipacketserial();
  static const int kIPacketSerialFieldNumber = 3;
  ::youmecommon::protobuf::int32 ipacketserial() const;
  void set_ipacketserial(::youmecommon::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:youmecommon.jitterbufferhead)
 private:
  inline void set_has_iver();
  inline void clear_has_iver();
  inline void set_has_iconv();
  inline void clear_has_iconv();
  inline void set_has_ipacketserial();
  inline void clear_has_ipacketserial();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::protobuf::int32 iver_;
  ::youmecommon::protobuf::int32 iconv_;
  ::youmecommon::protobuf::int32 ipacketserial_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static jitterbufferhead* default_instance_;
};
// -------------------------------------------------------------------

class jitterbufferpacket : public ::youmecommon::protobuf::MessageLite {
 public:
  jitterbufferpacket();
  virtual ~jitterbufferpacket();

  jitterbufferpacket(const jitterbufferpacket& from);

  inline jitterbufferpacket& operator=(const jitterbufferpacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const jitterbufferpacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const jitterbufferpacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(jitterbufferpacket* other);

  // implements Message ----------------------------------------------

  inline jitterbufferpacket* New() const { return New(NULL); }

  jitterbufferpacket* New(::youmecommon::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::youmecommon::protobuf::MessageLite& from);
  void CopyFrom(const jitterbufferpacket& from);
  void MergeFrom(const jitterbufferpacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::youmecommon::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::youmecommon::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(jitterbufferpacket* other);
  private:
  inline ::youmecommon::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::youmecommon::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .youmecommon.commonhead comhead = 1;
  bool has_comhead() const;
  void clear_comhead();
  static const int kComheadFieldNumber = 1;
  const ::youmecommon::commonhead& comhead() const;
  ::youmecommon::commonhead* mutable_comhead();
  ::youmecommon::commonhead* release_comhead();
  void set_allocated_comhead(::youmecommon::commonhead* comhead);

  // required .youmecommon.jitterbufferhead head = 2;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 2;
  const ::youmecommon::jitterbufferhead& head() const;
  ::youmecommon::jitterbufferhead* mutable_head();
  ::youmecommon::jitterbufferhead* release_head();
  void set_allocated_head(::youmecommon::jitterbufferhead* head);

  // required bytes payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:youmecommon.jitterbufferpacket)
 private:
  inline void set_has_comhead();
  inline void clear_has_comhead();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::youmecommon::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::youmecommon::protobuf::Arena* _arena_ptr_;

  ::youmecommon::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::youmecommon::commonhead* comhead_;
  ::youmecommon::jitterbufferhead* head_;
  ::youmecommon::protobuf::internal::ArenaStringPtr payload_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fec_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fec_2eproto();
  #endif
  friend void protobuf_AssignDesc_fec_2eproto();
  friend void protobuf_ShutdownFile_fec_2eproto();

  void InitAsDefaultInstance();
  static jitterbufferpacket* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// commonheadpacket

// required .youmecommon.commonhead head = 1;
inline bool commonheadpacket::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void commonheadpacket::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void commonheadpacket::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void commonheadpacket::clear_head() {
  if (head_ != NULL) head_->::youmecommon::commonhead::Clear();
  clear_has_head();
}
inline const ::youmecommon::commonhead& commonheadpacket::head() const {
  // @@protoc_insertion_point(field_get:youmecommon.commonheadpacket.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::youmecommon::commonhead* commonheadpacket::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::youmecommon::commonhead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.commonheadpacket.head)
  return head_;
}
inline ::youmecommon::commonhead* commonheadpacket::release_head() {
  clear_has_head();
  ::youmecommon::commonhead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void commonheadpacket::set_allocated_head(::youmecommon::commonhead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.commonheadpacket.head)
}

// -------------------------------------------------------------------

// commonhead

// required int32 iVer = 1;
inline bool commonhead::has_iver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void commonhead::set_has_iver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void commonhead::clear_has_iver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void commonhead::clear_iver() {
  iver_ = 0;
  clear_has_iver();
}
inline ::youmecommon::protobuf::int32 commonhead::iver() const {
  // @@protoc_insertion_point(field_get:youmecommon.commonhead.iVer)
  return iver_;
}
inline void commonhead::set_iver(::youmecommon::protobuf::int32 value) {
  set_has_iver();
  iver_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.commonhead.iVer)
}

// required .youmecommon.packettype type = 2;
inline bool commonhead::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void commonhead::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void commonhead::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void commonhead::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::youmecommon::packettype commonhead::type() const {
  // @@protoc_insertion_point(field_get:youmecommon.commonhead.type)
  return static_cast< ::youmecommon::packettype >(type_);
}
inline void commonhead::set_type(::youmecommon::packettype value) {
  assert(::youmecommon::packettype_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.commonhead.type)
}

// -------------------------------------------------------------------

// fechead

// required int32 iVer = 1;
inline bool fechead::has_iver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fechead::set_has_iver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fechead::clear_has_iver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fechead::clear_iver() {
  iver_ = 0;
  clear_has_iver();
}
inline ::youmecommon::protobuf::int32 fechead::iver() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iVer)
  return iver_;
}
inline void fechead::set_iver(::youmecommon::protobuf::int32 value) {
  set_has_iver();
  iver_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iVer)
}

// required int32 iConv = 2;
inline bool fechead::has_iconv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fechead::set_has_iconv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fechead::clear_has_iconv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fechead::clear_iconv() {
  iconv_ = 0;
  clear_has_iconv();
}
inline ::youmecommon::protobuf::int32 fechead::iconv() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iConv)
  return iconv_;
}
inline void fechead::set_iconv(::youmecommon::protobuf::int32 value) {
  set_has_iconv();
  iconv_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iConv)
}

// required int32 iGroupSerial = 3;
inline bool fechead::has_igroupserial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fechead::set_has_igroupserial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fechead::clear_has_igroupserial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fechead::clear_igroupserial() {
  igroupserial_ = 0;
  clear_has_igroupserial();
}
inline ::youmecommon::protobuf::int32 fechead::igroupserial() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iGroupSerial)
  return igroupserial_;
}
inline void fechead::set_igroupserial(::youmecommon::protobuf::int32 value) {
  set_has_igroupserial();
  igroupserial_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iGroupSerial)
}

// required int32 iGroupItemSerial = 4;
inline bool fechead::has_igroupitemserial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fechead::set_has_igroupitemserial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fechead::clear_has_igroupitemserial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fechead::clear_igroupitemserial() {
  igroupitemserial_ = 0;
  clear_has_igroupitemserial();
}
inline ::youmecommon::protobuf::int32 fechead::igroupitemserial() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iGroupItemSerial)
  return igroupitemserial_;
}
inline void fechead::set_igroupitemserial(::youmecommon::protobuf::int32 value) {
  set_has_igroupitemserial();
  igroupitemserial_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iGroupItemSerial)
}

// required int32 iType = 5;
inline bool fechead::has_itype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fechead::set_has_itype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fechead::clear_has_itype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fechead::clear_itype() {
  itype_ = 0;
  clear_has_itype();
}
inline ::youmecommon::protobuf::int32 fechead::itype() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iType)
  return itype_;
}
inline void fechead::set_itype(::youmecommon::protobuf::int32 value) {
  set_has_itype();
  itype_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iType)
}

// required int32 iK = 6;
inline bool fechead::has_ik() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fechead::set_has_ik() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fechead::clear_has_ik() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fechead::clear_ik() {
  ik_ = 0;
  clear_has_ik();
}
inline ::youmecommon::protobuf::int32 fechead::ik() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iK)
  return ik_;
}
inline void fechead::set_ik(::youmecommon::protobuf::int32 value) {
  set_has_ik();
  ik_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iK)
}

// required int32 iN = 7;
inline bool fechead::has_in() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fechead::set_has_in() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fechead::clear_has_in() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fechead::clear_in() {
  in_ = 0;
  clear_has_in();
}
inline ::youmecommon::protobuf::int32 fechead::in() const {
  // @@protoc_insertion_point(field_get:youmecommon.fechead.iN)
  return in_;
}
inline void fechead::set_in(::youmecommon::protobuf::int32 value) {
  set_has_in();
  in_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.fechead.iN)
}

// -------------------------------------------------------------------

// kcphead

// required int32 iVer = 1;
inline bool kcphead::has_iver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kcphead::set_has_iver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kcphead::clear_has_iver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kcphead::clear_iver() {
  iver_ = 0;
  clear_has_iver();
}
inline ::youmecommon::protobuf::int32 kcphead::iver() const {
  // @@protoc_insertion_point(field_get:youmecommon.kcphead.iVer)
  return iver_;
}
inline void kcphead::set_iver(::youmecommon::protobuf::int32 value) {
  set_has_iver();
  iver_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.kcphead.iVer)
}

// required int32 iConv = 2;
inline bool kcphead::has_iconv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kcphead::set_has_iconv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kcphead::clear_has_iconv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kcphead::clear_iconv() {
  iconv_ = 0;
  clear_has_iconv();
}
inline ::youmecommon::protobuf::int32 kcphead::iconv() const {
  // @@protoc_insertion_point(field_get:youmecommon.kcphead.iConv)
  return iconv_;
}
inline void kcphead::set_iconv(::youmecommon::protobuf::int32 value) {
  set_has_iconv();
  iconv_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.kcphead.iConv)
}

// -------------------------------------------------------------------

// kcppacket

// required .youmecommon.commonhead comhead = 1;
inline bool kcppacket::has_comhead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kcppacket::set_has_comhead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kcppacket::clear_has_comhead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kcppacket::clear_comhead() {
  if (comhead_ != NULL) comhead_->::youmecommon::commonhead::Clear();
  clear_has_comhead();
}
inline const ::youmecommon::commonhead& kcppacket::comhead() const {
  // @@protoc_insertion_point(field_get:youmecommon.kcppacket.comhead)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comhead_ != NULL ? *comhead_ : *default_instance().comhead_;
#else
  return comhead_ != NULL ? *comhead_ : *default_instance_->comhead_;
#endif
}
inline ::youmecommon::commonhead* kcppacket::mutable_comhead() {
  set_has_comhead();
  if (comhead_ == NULL) {
    comhead_ = new ::youmecommon::commonhead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.kcppacket.comhead)
  return comhead_;
}
inline ::youmecommon::commonhead* kcppacket::release_comhead() {
  clear_has_comhead();
  ::youmecommon::commonhead* temp = comhead_;
  comhead_ = NULL;
  return temp;
}
inline void kcppacket::set_allocated_comhead(::youmecommon::commonhead* comhead) {
  delete comhead_;
  comhead_ = comhead;
  if (comhead) {
    set_has_comhead();
  } else {
    clear_has_comhead();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.kcppacket.comhead)
}

// required .youmecommon.kcphead head = 2;
inline bool kcppacket::has_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kcppacket::set_has_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kcppacket::clear_has_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kcppacket::clear_head() {
  if (head_ != NULL) head_->::youmecommon::kcphead::Clear();
  clear_has_head();
}
inline const ::youmecommon::kcphead& kcppacket::head() const {
  // @@protoc_insertion_point(field_get:youmecommon.kcppacket.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::youmecommon::kcphead* kcppacket::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::youmecommon::kcphead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.kcppacket.head)
  return head_;
}
inline ::youmecommon::kcphead* kcppacket::release_head() {
  clear_has_head();
  ::youmecommon::kcphead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void kcppacket::set_allocated_head(::youmecommon::kcphead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.kcppacket.head)
}

// required bytes payload = 3;
inline bool kcppacket::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void kcppacket::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void kcppacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void kcppacket::clear_payload() {
  payload_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& kcppacket::payload() const {
  // @@protoc_insertion_point(field_get:youmecommon.kcppacket.payload)
  return payload_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void kcppacket::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:youmecommon.kcppacket.payload)
}
inline void kcppacket::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:youmecommon.kcppacket.payload)
}
inline void kcppacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:youmecommon.kcppacket.payload)
}
inline ::std::string* kcppacket::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:youmecommon.kcppacket.payload)
  return payload_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* kcppacket::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void kcppacket::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:youmecommon.kcppacket.payload)
}

// -------------------------------------------------------------------

// fecpacket

// required .youmecommon.commonhead comhead = 1;
inline bool fecpacket::has_comhead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fecpacket::set_has_comhead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fecpacket::clear_has_comhead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fecpacket::clear_comhead() {
  if (comhead_ != NULL) comhead_->::youmecommon::commonhead::Clear();
  clear_has_comhead();
}
inline const ::youmecommon::commonhead& fecpacket::comhead() const {
  // @@protoc_insertion_point(field_get:youmecommon.fecpacket.comhead)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comhead_ != NULL ? *comhead_ : *default_instance().comhead_;
#else
  return comhead_ != NULL ? *comhead_ : *default_instance_->comhead_;
#endif
}
inline ::youmecommon::commonhead* fecpacket::mutable_comhead() {
  set_has_comhead();
  if (comhead_ == NULL) {
    comhead_ = new ::youmecommon::commonhead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.fecpacket.comhead)
  return comhead_;
}
inline ::youmecommon::commonhead* fecpacket::release_comhead() {
  clear_has_comhead();
  ::youmecommon::commonhead* temp = comhead_;
  comhead_ = NULL;
  return temp;
}
inline void fecpacket::set_allocated_comhead(::youmecommon::commonhead* comhead) {
  delete comhead_;
  comhead_ = comhead;
  if (comhead) {
    set_has_comhead();
  } else {
    clear_has_comhead();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.fecpacket.comhead)
}

// required .youmecommon.fechead head = 2;
inline bool fecpacket::has_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fecpacket::set_has_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fecpacket::clear_has_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fecpacket::clear_head() {
  if (head_ != NULL) head_->::youmecommon::fechead::Clear();
  clear_has_head();
}
inline const ::youmecommon::fechead& fecpacket::head() const {
  // @@protoc_insertion_point(field_get:youmecommon.fecpacket.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::youmecommon::fechead* fecpacket::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::youmecommon::fechead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.fecpacket.head)
  return head_;
}
inline ::youmecommon::fechead* fecpacket::release_head() {
  clear_has_head();
  ::youmecommon::fechead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void fecpacket::set_allocated_head(::youmecommon::fechead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.fecpacket.head)
}

// required bytes payload = 3;
inline bool fecpacket::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fecpacket::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fecpacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fecpacket::clear_payload() {
  payload_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& fecpacket::payload() const {
  // @@protoc_insertion_point(field_get:youmecommon.fecpacket.payload)
  return payload_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void fecpacket::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:youmecommon.fecpacket.payload)
}
inline void fecpacket::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:youmecommon.fecpacket.payload)
}
inline void fecpacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:youmecommon.fecpacket.payload)
}
inline ::std::string* fecpacket::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:youmecommon.fecpacket.payload)
  return payload_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* fecpacket::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void fecpacket::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:youmecommon.fecpacket.payload)
}

// -------------------------------------------------------------------

// jitterbufferhead

// required int32 iVer = 1;
inline bool jitterbufferhead::has_iver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jitterbufferhead::set_has_iver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jitterbufferhead::clear_has_iver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jitterbufferhead::clear_iver() {
  iver_ = 0;
  clear_has_iver();
}
inline ::youmecommon::protobuf::int32 jitterbufferhead::iver() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferhead.iVer)
  return iver_;
}
inline void jitterbufferhead::set_iver(::youmecommon::protobuf::int32 value) {
  set_has_iver();
  iver_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.jitterbufferhead.iVer)
}

// required int32 iConv = 2;
inline bool jitterbufferhead::has_iconv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void jitterbufferhead::set_has_iconv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void jitterbufferhead::clear_has_iconv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void jitterbufferhead::clear_iconv() {
  iconv_ = 0;
  clear_has_iconv();
}
inline ::youmecommon::protobuf::int32 jitterbufferhead::iconv() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferhead.iConv)
  return iconv_;
}
inline void jitterbufferhead::set_iconv(::youmecommon::protobuf::int32 value) {
  set_has_iconv();
  iconv_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.jitterbufferhead.iConv)
}

// required int32 iPacketSerial = 3;
inline bool jitterbufferhead::has_ipacketserial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void jitterbufferhead::set_has_ipacketserial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void jitterbufferhead::clear_has_ipacketserial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void jitterbufferhead::clear_ipacketserial() {
  ipacketserial_ = 0;
  clear_has_ipacketserial();
}
inline ::youmecommon::protobuf::int32 jitterbufferhead::ipacketserial() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferhead.iPacketSerial)
  return ipacketserial_;
}
inline void jitterbufferhead::set_ipacketserial(::youmecommon::protobuf::int32 value) {
  set_has_ipacketserial();
  ipacketserial_ = value;
  // @@protoc_insertion_point(field_set:youmecommon.jitterbufferhead.iPacketSerial)
}

// -------------------------------------------------------------------

// jitterbufferpacket

// required .youmecommon.commonhead comhead = 1;
inline bool jitterbufferpacket::has_comhead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jitterbufferpacket::set_has_comhead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jitterbufferpacket::clear_has_comhead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jitterbufferpacket::clear_comhead() {
  if (comhead_ != NULL) comhead_->::youmecommon::commonhead::Clear();
  clear_has_comhead();
}
inline const ::youmecommon::commonhead& jitterbufferpacket::comhead() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferpacket.comhead)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comhead_ != NULL ? *comhead_ : *default_instance().comhead_;
#else
  return comhead_ != NULL ? *comhead_ : *default_instance_->comhead_;
#endif
}
inline ::youmecommon::commonhead* jitterbufferpacket::mutable_comhead() {
  set_has_comhead();
  if (comhead_ == NULL) {
    comhead_ = new ::youmecommon::commonhead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.jitterbufferpacket.comhead)
  return comhead_;
}
inline ::youmecommon::commonhead* jitterbufferpacket::release_comhead() {
  clear_has_comhead();
  ::youmecommon::commonhead* temp = comhead_;
  comhead_ = NULL;
  return temp;
}
inline void jitterbufferpacket::set_allocated_comhead(::youmecommon::commonhead* comhead) {
  delete comhead_;
  comhead_ = comhead;
  if (comhead) {
    set_has_comhead();
  } else {
    clear_has_comhead();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.jitterbufferpacket.comhead)
}

// required .youmecommon.jitterbufferhead head = 2;
inline bool jitterbufferpacket::has_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void jitterbufferpacket::set_has_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void jitterbufferpacket::clear_has_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void jitterbufferpacket::clear_head() {
  if (head_ != NULL) head_->::youmecommon::jitterbufferhead::Clear();
  clear_has_head();
}
inline const ::youmecommon::jitterbufferhead& jitterbufferpacket::head() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferpacket.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::youmecommon::jitterbufferhead* jitterbufferpacket::mutable_head() {
  set_has_head();
  if (head_ == NULL) {
    head_ = new ::youmecommon::jitterbufferhead;
  }
  // @@protoc_insertion_point(field_mutable:youmecommon.jitterbufferpacket.head)
  return head_;
}
inline ::youmecommon::jitterbufferhead* jitterbufferpacket::release_head() {
  clear_has_head();
  ::youmecommon::jitterbufferhead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void jitterbufferpacket::set_allocated_head(::youmecommon::jitterbufferhead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:youmecommon.jitterbufferpacket.head)
}

// required bytes payload = 3;
inline bool jitterbufferpacket::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void jitterbufferpacket::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void jitterbufferpacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void jitterbufferpacket::clear_payload() {
  payload_.ClearToEmptyNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& jitterbufferpacket::payload() const {
  // @@protoc_insertion_point(field_get:youmecommon.jitterbufferpacket.payload)
  return payload_.GetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jitterbufferpacket::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:youmecommon.jitterbufferpacket.payload)
}
inline void jitterbufferpacket::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:youmecommon.jitterbufferpacket.payload)
}
inline void jitterbufferpacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:youmecommon.jitterbufferpacket.payload)
}
inline ::std::string* jitterbufferpacket::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:youmecommon.jitterbufferpacket.payload)
  return payload_.MutableNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* jitterbufferpacket::release_payload() {
  clear_has_payload();
  return payload_.ReleaseNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void jitterbufferpacket::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::youmecommon::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:youmecommon.jitterbufferpacket.payload)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace youmecommon

#ifndef SWIG
namespace youmecommon {
namespace protobuf {

template <> struct is_proto_enum< ::youmecommon::packettype> : ::youmecommon::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fec_2eproto__INCLUDED
